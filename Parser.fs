module Parser =    

    open Tokenizer
    open Lang

    let rec buildNestedLambda (args: string list) (body: Expr) : Expr =
        match args with
        | [] -> body
        | hd::tl -> Lambda(hd, buildNestedLambda tl body)

    let parseExpr (tokens: List<Token>) = 
        let rec parseAll (tokens : List<Token>) (acc : List<Expr>) =
            match tokens with
            | [] -> List.rev acc
            | _ ->
                let expr, rest = parse tokens
                parseAll rest (expr :: acc)

        and parse (tokens : List<Token>) =
            match tokens with
            | TokenInt n::tail -> Int n, tail

            | TokenBool b::tail -> Bool b, tail
            
            | TokenVar v :: tail ->
                let expr =
                    match v with
                    | "head" | "tail" | "isEmpty" | "length"
                    | "map" | "filter" | "fold" | "mapfold" -> PredefFunc v
                    | _ -> Var v
                expr, tail

            | TokenOperation op :: tail ->
                let arg1, tail1 = parse tail
                let arg2, tail2 = parse tail1
                Apply(Apply(PredefFunc op, arg1), arg2), tail2

            | TokenIf::tail ->
                let cond, tail1 = parse tail
                let thenExpr, tail2 = parse tail1
                let elseExpr, tail3 = parse tail2
                If(cond, thenExpr, elseExpr), tail3

            | TokenGets::TokenVar v::tail ->
                let boundExpr, tail1 = parse tail
                Gets(v, boundExpr), tail1


            // Generated by ChatGPT
            | TokenLambda :: tail ->
                let rec gatherVars tokens acc =
                    match tokens with
                    | TokenVar v :: rest -> gatherVars rest (v :: acc)
                    | TokenRightArrow :: rest -> List.rev acc, rest
                    | _ -> failwith "Invalid lambda parameter list"

                let vars, rest = gatherVars tail []
                let body, remaining = parse rest

                // Превращаем список параметров в вложенные лямбды
                let lam = List.foldBack (fun v acc -> Lambda(v, acc)) vars body
                lam, remaining
            // until here


            // Generated by ChatGPT
            | TokenRecursive :: TokenGets :: TokenVar name :: TokenLambda :: tail ->
                // Соберём список аргументов до ->
                let rec collectArgs toks acc =
                    match toks with
                    | TokenVar arg :: rest -> collectArgs rest (arg::acc)
                    | TokenRightArrow :: rest -> List.rev acc, rest
                    | _ -> failwith "Invalid function argument list in recursive definition"

                let args, afterArrow = collectArgs tail []
                let body, rest = parse afterArrow
                GetsRec(name, buildNestedLambda args body), rest
            // until here


            // Generated by ChatGPT
            | TokenLeftBracket :: tail ->
                // Разбираем все выражения внутри скобок
                let rec parseExprs tokens acc =
                    match tokens with
                    | TokenRightBracket :: rest -> List.rev acc, rest
                    | [] -> failwith "Unclosed parenthesis"
                    | _ ->
                        let expr, rest = parse tokens
                        parseExprs rest (expr :: acc)

                let exprs, rest = parseExprs tail []

                match exprs with
                | [] -> failwith "Empty application"
                | f :: args ->
                    let app = List.fold (fun acc arg -> Apply(acc, arg)) f args
                    app, rest
            // until here


            | TokenLBracketList::tail ->
                let rec parseList tokens acc =
                    match tokens with
                    | TokenRBracketList :: tail' -> List.rev acc, tail'
                    | _ ->
                        let arg, tail1 = parse tokens
                        parseList tail1 (arg :: acc)
                let args, tail1 = parseList tail []
                List(args), tail1
                
        parseAll tokens []


    let tokens = tokenize "$ <- fact \ x y z ->
                                                    if 
                                                        <= x 1
                                                        1
                                                        * x (fact - x 1)"
    let ast = parseExpr tokens
    printfn "%A" ast


    let myList = tokenize "<- x (f [a b c] 5)"
    let list_ast = parseExpr myList
    printfn "%A" list_ast

    let myLambda = tokenize "<- add \ x y -> + x y"
    let lambdaAst = parseExpr myLambda
    printfn "%A" lambdaAst
